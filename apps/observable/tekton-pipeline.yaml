apiVersion: v1
kind: Namespace
metadata:
  name: tekton-pipelines
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: build-observable-image
  namespace: tekton-pipelines
spec:
  params:
  - name: git-url
    type: string
    description: Git repository URL
  - name: git-revision
    type: string
    description: Git revision to checkout
    default: "main"
  - name: image-url
    type: string
    description: Registry URL for the built image
  workspaces:
  - name: source
    description: Workspace for source code
  - name: dockerconfig
    description: Docker config for registry access
    optional: true
  steps:
  - name: git-clone
    image: alpine/git:latest
    script: |
      #!/bin/sh
      set -e
      echo "Cloning $(params.git-url) at $(params.git-revision)"
      git clone $(params.git-url) $(workspaces.source.path)/source
      cd $(workspaces.source.path)/source
      git checkout $(params.git-revision)
      ls -la apps/observable/
  
  - name: check-changes
    image: alpine:latest
    script: |
      #!/bin/sh
      set -e
      cd $(workspaces.source.path)/source/apps/observable
      
      # Check if conda-environment.yml or Dockerfile changed
      if git diff HEAD~1 --name-only | grep -E "(conda-environment\.yml|Dockerfile|\.md$)" > /dev/null; then
        echo "Changes detected in dependencies or dashboards - proceeding with build"
        echo "true" > /tmp/should-build
      else
        echo "No relevant changes detected - skipping build"
        echo "false" > /tmp/should-build
      fi
      
  - name: build-and-push
    image: gcr.io/kaniko-project/executor:latest
    env:
    - name: DOCKER_CONFIG
      value: /kaniko/.docker
    script: |
      #!/busybox/sh
      set -e
      
      # Check if we should build
      if [ "$(cat /tmp/should-build)" = "false" ]; then
        echo "Skipping build - no relevant changes"
        exit 0
      fi
      
      cd $(workspaces.source.path)/source/apps/observable
      
      echo "Building image $(params.image-url)"
      /kaniko/executor \
        --context=. \
        --dockerfile=./Dockerfile \
        --destination=$(params.image-url) \
        --insecure \
        --skip-tls-verify
        
      echo "Image built and pushed successfully: $(params.image-url)"
    volumeMounts:
    - name: docker-config
      mountPath: /kaniko/.docker
      readOnly: true
  
  volumes:
  - name: docker-config
    emptyDir: {}
---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: observable-gitops-pipeline
  namespace: tekton-pipelines
spec:
  params:
  - name: git-url
    type: string
    description: Git repository URL
  - name: git-revision
    type: string
    description: Git revision
    default: "main"
  - name: image-url
    type: string
    description: Image URL
    default: "registry.registry.svc.cluster.local:5000/observable-conda:latest"
  - name: deployment-namespace
    type: string
    description: Namespace for deployment
    default: "observable"
  
  workspaces:
  - name: shared-data
    description: Shared workspace
  
  tasks:
  - name: build-image
    taskRef:
      name: build-observable-image
    params:
    - name: git-url
      value: $(params.git-url)
    - name: git-revision
      value: $(params.git-revision)
    - name: image-url
      value: $(params.image-url)
    workspaces:
    - name: source
      workspace: shared-data
      
  - name: update-deployment
    runAfter: ["build-image"]
    taskSpec:
      params:
      - name: image-url
        type: string
      - name: deployment-namespace
        type: string
      steps:
      - name: rollout-restart
        image: bitnami/kubectl:latest
        script: |
          #!/bin/bash
          set -e
          echo "Restarting deployment to use new image: $(params.image-url)"
          kubectl rollout restart deployment/observable -n $(params.deployment-namespace)
          kubectl rollout status deployment/observable -n $(params.deployment-namespace) --timeout=300s
          echo "Deployment restarted successfully"
    params:
    - name: image-url
      value: $(params.image-url)
    - name: deployment-namespace
      value: $(params.deployment-namespace)
---
apiVersion: tekton.dev/v1beta1
kind: TriggerTemplate
metadata:
  name: observable-trigger-template
  namespace: tekton-pipelines
spec:
  params:
  - name: git-revision
    description: The git revision
    default: main
  - name: git-commit-message
    description: The git commit message
  - name: git-repo-url
    description: The git repository url
  - name: git-repo-name
    description: The name of the deployment to be created / patched
    
  resourcetemplates:
  - apiVersion: tekton.dev/v1beta1
    kind: PipelineRun
    metadata:
      generateName: observable-pipeline-run-
      namespace: tekton-pipelines
    spec:
      pipelineRef:
        name: observable-gitops-pipeline
      params:
      - name: git-url
        value: $(tt.params.git-repo-url)
      - name: git-revision
        value: $(tt.params.git-revision)
      workspaces:
      - name: shared-data
        volumeClaimTemplate:
          spec:
            accessModes:
            - ReadWriteOnce
            resources:
              requests:
                storage: 1Gi
---
apiVersion: triggers.tekton.dev/v1alpha1
kind: TriggerBinding
metadata:
  name: observable-pipelinebinding
  namespace: tekton-pipelines
spec:
  params:
  - name: git-repo-url
    value: $(body.repository.clone_url)
  - name: git-repo-name
    value: $(body.repository.name)
  - name: git-revision
    value: $(body.after)
  - name: git-commit-message
    value: $(body.head_commit.message)
---
apiVersion: triggers.tekton.dev/v1alpha1
kind: EventListener
metadata:
  name: observable-listener
  namespace: tekton-pipelines
spec:
  serviceAccountName: tekton-triggers-sa
  triggers:
  - name: observable-trigger
    bindings:
    - ref: observable-pipelinebinding
    template:
      ref: observable-trigger-template
    interceptors:
    - name: "only-on-observable-changes"
      ref:
        name: "cel"
      params:
      - name: "filter"
        value: >
          body.commits.exists(c, c.modified.exists(f, 
            f.startsWith('apps/observable/') && 
            (f.endsWith('.md') || f.endsWith('conda-environment.yml') || f.endsWith('Dockerfile'))
          ))
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tekton-triggers-sa
  namespace: tekton-pipelines
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: tekton-triggers-minimal
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["tekton.dev"]
  resources: ["eventlisteners", "triggers", "triggerbindings", "triggertemplates", "tasks", "taskruns", "pipelines", "pipelineruns"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch", "update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tekton-triggers-binding
subjects:
- kind: ServiceAccount
  name: tekton-triggers-sa
  namespace: tekton-pipelines
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: tekton-triggers-minimal
---
apiVersion: v1
kind: Service
metadata:
  name: el-observable-listener
  namespace: tekton-pipelines
spec:
  ports:
  - name: http-listener
    port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    eventlistener: observable-listener
  type: ClusterIP